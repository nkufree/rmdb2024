# 数据库设计与实现文档

## 设计思路

### 存储管理

#### 磁盘管理

磁盘管理中需要提供对磁盘上的文件操作的功能：

1. 创建文件
2. 打开文件
3. 关闭文件
4. 销毁文件
5. 写入文件
6. 读取文件

由于在缓冲池中文件以页的方式进行管理，所以此处的写入和读取文件也按照页的方式进行。

#### 缓冲池管理

为了便于对文件进行更加细致化的管理，数据库自己实现了一个基于分页机制的缓冲池，需要提供以下功能：

1. 分配新页
2. 获取页
3. 淘汰页
4. 更新页
5. 取消固定页
6. 删除页
7. 将一页写入磁盘
8. 将所有页写入磁盘

在选择淘汰页的过程中，需要考虑缓冲池替换策略，实现以下功能：

1. 淘汰页
2. 固定页
3. 取消固定页

#### 记录管理

为了实现更加精细化的管理，需要实现记录管理器，提供以下功能：

1. 获取记录
2. 插入记录
3. 删除记录
4. 更新记录

其中插入记录需要考虑自动选择一个空闲位置插入，和在指定位置插入（用于事务异常处理）。

#### 记录遍历

为了方便后续查询执行，还需要提供遍历表中的所有记录的接口。

### 查询执行

#### DDL语句

DDL语句包括以下内容：

1. 创建表：创建表文件，初始化表信息，将表添加到数据库打开表列表中。
2. 删除表：关闭表文件，删除索引文件，删除表文件，更新数据库信息。

#### DML语句

DML语句包括以下内容：

1. `insert`语句：构建插入数据对应的二进制数据，写入对应的表和索引中。
2. `delete`语句：从表中查询所有符合条件的记录，删除记录和对应的索引。
3. `update`语句：从表中查询所有符合条件的记录，更新记录和对应的索引。

#### DQL语句

DQL语句需要实现`select`语句，大体上可以分为三个算子：记录遍历、投影、连接。

记录遍历算子需要从表中取出符合条件的记录，投影算子需要将记录转换为需要查询的字段，如果有连接查询则需要使用连接算子拼接字段。

### 唯一索引

#### 索引的创建、删除和展示

1. 创建索引：创建并打开索引文件，将表中原有的数据插入索引中。
2. 删除索引：关闭并删除索引索引文件。
3. 展示索引：遍历表的所有索引并输出。

#### 索引查询

我们实现的是 B+ 树索引，首先需要实现索引匹配规则，使用最长匹配的索引进行查询，对外提供比较重要的功能如下：

1. 查找大于或等于指定键所属的叶子节点。
2. 查找大于指定键所属的叶子节点。
3. 插入指定键。
4. 删除指定键。

#### 索引维护

需要考虑唯一索引的约束性：

1. 插入键时，如果键已经存在则抛出异常。
2. 更新键时，如果更新后的键已存在则抛出异常，如果更新后与更新前的键相同则不抛出异常。


### 聚合函数与分组统计

#### 聚合函数

新增聚合算子，实现以下聚合函数：

1. `MAX`：依次取出表中的记录，统计所需字段的最大值。
2. `MIN`：依次取出表中的记录，统计所需字段的最小值。
3. `COUNT`：依次取出表中的记录，按照字段类型计算所需字段的总和。

#### 分组统计

分组统计的实现也放到聚合算子中，需要按照指定字段分组，计算所需值。

### 不相关子查询

不相关子查询需要修改查询条件的右值，新增子查询和集合类型。在使用到条件判断的地方都需要事先判断查询条件的右值是否为子查询，若是则优先执行子查询。

### 事务控制语句

#### 开启事务

开启事务需要为新事务分配一个新的事务`id`，加入到全局事务表中。

#### 提交事务

提交事务需要执行所有写操作，释放事务持有的锁，刷新事务日志。

#### 回滚事务

回滚事务需要取消所有的写操作，修改相应的表文件和索引文件，修改完毕后释放所有锁和资源，刷新事务日志。

### 冲突可串行化

实现表级共享锁和排他锁，在查询时使用共享锁，插入、删除、更新时使用排他锁。释放锁时优先保证等待队列中的第一个事务获取锁，再检查后续是否有事务也可以获取锁。

实现wait-die策略，如果开始较晚的事务在等待开始较早的事务释放锁，则该事务会回滚。

### 基于静态检查点的故障恢复

#### 故障恢复分为三个阶段：

1. 日志分析：从日志文件中反序列化出日志，按照事务划分日志。
2. `REDO`：按照事务开始顺序执行依次执行操作，实现数据库文件的更新。
3. `UNDO`：对于所有回滚或未提交的事务，回滚其所有操作。

#### 静态检查点

创建静态检查点需要获取事务锁，保证无法分配新事务`id`，然后等待所有现有事务完成，将日志文件和缓冲池中的内容刷新到磁盘中，写入检查点日志并向检查点文件中记录检查点日志在日志文件中的偏移量。

## 系统框架




## 实现重点

### `Value`

在框架给定的`Value`结构中，实现`Value`比较大小所需的运算符重载，例如判断两个值相等：

```c++
bool operator==(const Value &rhs) const {
    if (type != rhs.type) throw IncompatibleTypeError(coltype2str(type), coltype2str(rhs.type));
    switch (type) {
        case TYPE_INT:
            return int_val == rhs.int_val;
        case TYPE_FLOAT:
            return float_val == rhs.float_val;
        case TYPE_STRING:
            return strncmp(str_val.c_str(), rhs.str_val.c_str(), str_len) == 0;
        default:
            throw InternalError("Unexpected value type");
    }
}
```

还需要实现值的类型转换，为了实现从表中加载数据，也需要增加字符串类型转换为整型或浮点型

```c++
void value_cast(ColType new_type) {
    if (type == new_type) return;
    if (type == TYPE_INT && new_type == TYPE_FLOAT) {
        float_val = int_val;
    } else if (type == TYPE_FLOAT && new_type == TYPE_INT) {
        int_val = float_val;
    } else if(type == TYPE_STRING && new_type == TYPE_INT) {
        sscanf(str_val.c_str(), "%d", &int_val);
    } else if(type == TYPE_STRING && new_type == TYPE_FLOAT) {
        sscanf(str_val.c_str(), "%f", &float_val);
    } else {
        throw IncompatibleTypeError(coltype2str(type), coltype2str(new_type));
    }
    type = new_type;
}
```

### `Condition`

在`Condition`类中，我们给定了以下属性

```c++
struct Condition {
    TabCol lhs_col;   // left-hand side column
    CompOp op;        // comparison operator
    TabCol rhs_col;   // right-hand side column
    Value rhs_val;    // right-hand side value
    std::shared_ptr<Query> rhs_query;
    std::shared_ptr<Plan> rhs_plan;
    std::shared_ptr<PortalStmt> rhs_portal;
    std::set<Value> rhs_set;
    CondRhsType rhs_type;
    std::vector<ColMeta>::const_iterator lhs_match_col;
    std::vector<ColMeta>::const_iterator rhs_match_col;
}
```

为了适配子查询，我们增加了中间结果的存放位置`rhs_query`、`rhs_plan`、`rhs_portal`。在子查询执行完毕后，该条件的右值会退化为一个具体的`Value`或`Value`的集合。

对于条件查询我们做了以下两个优化：

1. 减少类型转换次数：在开始检索记录之前，首先检查条件的两侧类型是否相同，如果不同且类型转换合法，则将右值改为与左值相同的类型。
2. 减少查询过程中对列的获取：在条件中增加`lhs_match_col`和`rhs_match_col`，用于记录左值和右值对应的表中的列的迭代器。

### B+树索引

在我们实现的B+树中，内部节点的键和值的个数相等。

B+树索引涉及到的方法比较多，

### 事务控制


### 冲突可串行化



### 故障恢复



## 代码注释

我们在重要API对应的方法的实现前会添加该方法的注释，格式如下：

```c++
/**
 * @brief 方法功能介绍
 *
 * @param 参数介绍
 * @return 返回值介绍
 * @note 其他需要注意的点
 */
```

## 遇到问题

### 内存泄漏

在不断接受事务的过程中，由于部分使用`new`分配出去的空间没有释放，会导致数据库内存占用不断升高，经过排查后找出比较严重的问题：

1. 事务修改记录的操作没有释放
2. 在索引查询中部分结点管理没有释放
3. 在日志管理中没有释放表名所占空间
4. 事务结束后也一直存放在事务管理表中没有释放

在后续的过程中我们对以上问题涉及的对象在适当的位置进行释放。

### 删除表后新建表访问内容不正确

由于删除表会关闭文件，新建表会打开文件，这两个文件对应的`fd`可能相同，导致在缓冲池中可能会访问到错误的内容。因此在删除表后，需要在缓冲池中删除对应的文件页。

## 性能优化

### `count(*)` 优化

我们对全表的记录条数统计进行优化，直接对表中所有页面的记录数进行求和，省去遍历表中记录的步骤。