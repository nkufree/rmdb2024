# 数据库设计与实现文档

## 设计思路

### 存储管理

#### 磁盘管理

磁盘管理中需要提供对磁盘上的文件操作的功能：

1. 创建文件
2. 打开文件
3. 关闭文件
4. 销毁文件
5. 写入文件
6. 读取文件

由于在缓冲池中文件以页的方式进行管理，所以此处的写入和读取文件也按照页的方式进行。

#### 缓冲池管理

为了便于对文件进行更加细致化的管理，数据库自己实现了一个基于分页机制的缓冲池，需要提供以下功能：

1. 分配新页
2. 获取页
3. 淘汰页
4. 更新页
5. 取消固定页
6. 删除页
7. 将一页写入磁盘
8. 将所有页写入磁盘

在选择淘汰页的过程中，需要考虑缓冲池替换策略，实现以下功能：

1. 淘汰页
2. 固定页
3. 取消固定页

#### 记录管理

为了实现更加精细化的管理，需要实现记录管理器，提供以下功能：

1. 获取记录
2. 插入记录
3. 删除记录
4. 更新记录

其中插入记录需要考虑自动选择一个空闲位置插入，和在指定位置插入（用于事务异常处理）。

#### 记录遍历

为了方便后续查询执行，还需要提供遍历表中的所有记录的接口。

### 查询执行

#### DDL语句

DDL语句包括以下内容：

1. 创建表：创建表文件，初始化表信息，将表添加到数据库打开表列表中。
2. 删除表：关闭表文件，删除索引文件，删除表文件，更新数据库信息。

#### DML语句

DML语句包括以下内容：

1. `insert`语句：构建插入数据对应的二进制数据，写入对应的表和索引中。
2. `delete`语句：从表中查询所有符合条件的记录，删除记录和对应的索引。
3. `update`语句：从表中查询所有符合条件的记录，更新记录和对应的索引。

#### DQL语句

DQL语句需要实现`select`语句，大体上可以分为三个算子：记录遍历、投影、连接。

记录遍历算子需要从表中取出符合条件的记录，投影算子需要将记录转换为需要查询的字段，如果有连接查询则需要使用连接算子拼接字段。

### 唯一索引

#### 索引的创建、删除和展示

1. 创建索引：创建并打开索引文件，将表中原有的数据插入索引中。
2. 删除索引：关闭并删除索引索引文件。
3. 展示索引：遍历表的所有索引并输出。

#### 索引查询

我们实现的是 B+ 树索引，首先需要实现索引匹配规则，使用最长匹配的索引进行查询，对外提供比较重要的功能如下：

1. 查找大于或等于指定键所属的叶子节点。
2. 查找大于指定键所属的叶子节点。
3. 插入指定键。
4. 删除指定键。

#### 索引维护

需要考虑唯一索引的约束性：

1. 插入键时，如果键已经存在则抛出异常。
2. 更新键时，如果更新后的键已存在则抛出异常，如果更新后与更新前的键相同则不抛出异常。


### 聚合函数与分组统计

#### 聚合函数

新增聚合算子，实现以下聚合函数：

1. `MAX`：依次取出表中的记录，统计所需字段的最大值。
2. `MIN`：依次取出表中的记录，统计所需字段的最小值。
3. `COUNT`：依次取出表中的记录，按照字段类型计算所需字段的总和。

#### 分组统计

分组统计的实现也放到聚合算子中，需要按照指定字段分组，计算所需值。

### 不相关子查询

不相关子查询需要修改查询条件的右值，新增子查询和集合类型。在使用到条件判断的地方都需要事先判断查询条件的右值是否为子查询，若是则优先执行子查询。

### 事务控制语句

#### 开启事务

开启事务需要为新事务分配一个新的事务`id`，加入到全局事务表中。

#### 提交事务

提交事务需要执行所有写操作，释放事务持有的锁，刷新事务日志。

#### 回滚事务

回滚事务需要取消所有的写操作，修改相应的表文件和索引文件，修改完毕后释放所有锁和资源，刷新事务日志。

### 冲突可串行化

实现表级共享锁和排他锁，在查询时使用共享锁，插入、删除、更新时使用排他锁。释放锁时优先保证等待队列中的第一个事务获取锁，再检查后续是否有事务也可以获取锁。

实现wait-die策略，如果开始较晚的事务在等待开始较早的事务释放锁，则该事务会回滚。

### 基于静态检查点的故障恢复

#### 故障恢复分为三个阶段：

1. 日志分析：从日志文件中反序列化出日志，按照事务划分日志。
2. `REDO`：按照事务开始顺序执行依次执行操作，实现数据库文件的更新。
3. `UNDO`：对于所有回滚或未提交的事务，回滚其所有操作。

#### 静态检查点

创建静态检查点需要获取事务锁，保证无法分配新事务`id`，然后等待所有现有事务完成，将日志文件和缓冲池中的内容刷新到磁盘中，写入检查点日志并向检查点文件中记录检查点日志在日志文件中的偏移量。

## 系统框架




## 实现重点

### `Value`

在框架给定的`Value`结构中，实现`Value`比较大小所需的运算符重载，例如判断两个值相等：

```c++
bool operator==(const Value &rhs) const {
    if (type != rhs.type) throw IncompatibleTypeError(coltype2str(type), coltype2str(rhs.type));
    switch (type) {
        case TYPE_INT:
            return int_val == rhs.int_val;
        case TYPE_FLOAT:
            return float_val == rhs.float_val;
        case TYPE_STRING:
            return strncmp(str_val.c_str(), rhs.str_val.c_str(), str_len) == 0;
        default:
            throw InternalError("Unexpected value type");
    }
}
```

还需要实现值的类型转换，为了实现从表中加载数据，也需要增加字符串类型转换为整型或浮点型

```c++
void value_cast(ColType new_type) {
    if (type == new_type) return;
    if (type == TYPE_INT && new_type == TYPE_FLOAT) {
        float_val = int_val;
    } else if (type == TYPE_FLOAT && new_type == TYPE_INT) {
        int_val = float_val;
    } else if(type == TYPE_STRING && new_type == TYPE_INT) {
        sscanf(str_val.c_str(), "%d", &int_val);
    } else if(type == TYPE_STRING && new_type == TYPE_FLOAT) {
        sscanf(str_val.c_str(), "%f", &float_val);
    } else {
        throw IncompatibleTypeError(coltype2str(type), coltype2str(new_type));
    }
    type = new_type;
}
```

### `Condition`

在`Condition`类中，我们给定了以下属性

```c++
struct Condition {
    TabCol lhs_col;   // left-hand side column
    CompOp op;        // comparison operator
    TabCol rhs_col;   // right-hand side column
    Value rhs_val;    // right-hand side value
    std::shared_ptr<Query> rhs_query;
    std::shared_ptr<Plan> rhs_plan;
    std::shared_ptr<PortalStmt> rhs_portal;
    std::set<Value> rhs_set;
    CondRhsType rhs_type;
    std::vector<ColMeta>::const_iterator lhs_match_col;
    std::vector<ColMeta>::const_iterator rhs_match_col;
}
```

为了适配子查询，我们增加了中间结果的存放位置`rhs_query`、`rhs_plan`、`rhs_portal`。在子查询执行完毕后，该条件的右值会退化为一个具体的`Value`或`Value`的集合。

对于条件查询我们做了以下两个优化：

1. 减少类型转换次数：在开始检索记录之前，首先检查条件的两侧类型是否相同，如果不同且类型转换合法，则将右值改为与左值相同的类型。
2. 减少查询过程中对列的获取：在条件中增加`lhs_match_col`和`rhs_match_col`，用于记录左值和右值对应的表中的列的迭代器。

### B+树索引

在我们实现的B+树中，内部节点的键和值的个数相等。

B+树索引涉及到的方法比较多，在这里列出比较重要的两种方法。

#### 插入数据

插入数据的方法实现如下：

1. 获取根节点的锁。
2. 查找应插入的叶节点。
3. 将给定键值对插入叶节点。
4. 如果插入的位置是第一个位置，则需要循环向上更新父节点的第一个键值。
5. 如果插入后叶节点已满，则分裂该节点。

#### 删除数据

删除数据的方法实现如下：

1. 获取根节点的锁。
2. 查找删除的键所在叶节点。
3. 删除键值对。
4. 如果删除的是第一个键，则需要循环向上更新父节点的第一个键值。
5. 对叶节点进行合并或再分配操作。

### 事务控制

事务控制中比较重要的是事务回滚。

为了实现事务回滚，需要在插入、删除、更新数据前记录操作，并加入到事务的写操作集合中。

写操作记录的内容如下：

1. 插入数据：需要记录插入的表名和插入的位置`rid`。
2. 删除数据：需要记录删除的表名、删除的位置`rid`、删除的记录内容。
3. 更新数据：需要记录更新的表名、更新的位置`rid`、更新前的记录内容。

事务回滚可以分为两个步骤：回滚表中的记录和回滚索引中的记录。

为了正确恢复索引中的数据，需要在索引恢复前将删除的记录插入到表中原本删除的位置；在索引恢复完毕之后，对于插入操作需要删除该记录，对于更新操作需要更新该记录。

### 冲突可串行化

#### 表级锁

对于表级排他锁，实现的步骤如下：

1. 检查当前事务是否持有该表的共享锁，如果有则等待其他事务释放锁，如果只有当前事务持有共享锁则升级为排他锁。
2. 如果当前事务没有该表的锁，则检查是否有其他事务持有该表的锁，如果没有则获取该锁，否则进入等待队列等待唤醒。
3. 如果等待队列中有比自己开始早的事务，则抛出事务回滚异常。
4. 获取到锁后，将锁加入事务的锁集合中。

对于表级共享锁，实现的步骤如下：

1. 如果已经持有共享锁或排他锁，则无需加锁。
2. 如果当前表只有共享锁，则直接获取锁。
3. 如果当前表被加上排他锁，则进入等待队列。
4. 如果等待队列中有比自己开始早的事务，则抛出事务回滚异常。
5. 获取到锁后，将锁加入事务的锁集合中。

在具体的实现过程中，为了简化代码的复杂程度，我们设计锁的相容性矩阵，每次判断是否能够加锁都需要按照希望的锁和当前已加的锁在矩阵中查询锁的相容性。

#### 解锁

解锁的流程如下：

1. 获取该锁的等待队列。
2. 将当前项从等待队列中移除。
3. 如果还有其他事务持有锁，则直接返回。
4. 如果没有其他事务持有锁，为等待队列中的第一个事务赋予锁，其他持有与该事务相容的锁的事务均被赋予锁，唤醒这些线程，更新队列的加锁模式。

### 故障恢复

#### 日志分析

我们设计了如下成员变量：

```c++
std::unordered_map<PageId, RedoLogsInPage> redo_logs_map_;   // 记录每个page上需要redo的操作
std::map<lsn_t, std::shared_ptr<LogRecord>> log_records_;                       // 记录每个lsn对应的日志记录
std::unordered_map<txn_id_t, lsn_t> redo_txn_;               // 需要redo的事务，最后一条redo的日志的lsn
std::unordered_map<txn_id_t, lsn_t> undo_txn_;                         // 需要undo的事务
int last_checkpoint_;                           // 最后一个checkpoint的lsn
std::vector<txn_id_t> txn_list_;                      // 事务列表
```


日志分析的流程如下：

1. 从日志文件起始位置开始，反序列化出日志头的信息。
2. 根据日志头信息判断日志类型，根据日志类型执行不同操作。其中比较重要的有：

    1. `begin`：将事务加入`undo`事务列表中。
    2. `commit`：将事务从`undo`事务列表中删除，加入`redo`事务列表中。
3. 将事务执行的操作按照日志顺序分配到各个页面上。

#### 重做事务

重做每个页面上的插入、删除、更新操作。

#### 回滚事务

对于回滚事务表中的事务，按照事务开始顺序的逆序回滚事务，更新对应的记录和索引。



## 代码注释

我们在重要API对应的方法的实现前会添加该方法的注释，格式如下：

```c++
/**
 * @brief 方法功能介绍
 *
 * @param 参数介绍
 * @return 返回值介绍
 * @note 其他需要注意的点
 */
```

## 遇到问题

### 内存泄漏

在不断接受事务的过程中，由于部分使用`new`分配出去的空间没有释放，会导致数据库内存占用不断升高，经过排查后找出比较严重的问题：

1. 事务修改记录的操作没有释放
2. 在索引查询中部分结点管理没有释放
3. 在日志管理中没有释放表名所占空间
4. 事务结束后也一直存放在事务管理表中没有释放

在后续的过程中我们对以上问题涉及的对象在适当的位置进行释放。

### 删除表后新建表访问内容不正确

由于删除表会关闭文件，新建表会打开文件，这两个文件对应的`fd`可能相同，导致在缓冲池中可能会访问到错误的内容。因此在删除表后，需要在缓冲池中删除对应的文件页。

## 性能优化

### `count(*)` 优化

我们对全表的记录条数统计进行优化，直接对表中所有页面的记录数进行求和，省去遍历表中记录的步骤。

### 锁的优化

我们在每个锁都设计了自己独有的互斥量，在通过锁的全局互斥量获取到锁的等待队列后，获取该锁的互斥量，释放锁的全局的互斥量。

### 其他优化

`update`更新索引时，如果出现重复键值，则抛出异常，执行事务回滚过程，省去在插入记录之前检查键在索引中是否存在的过程。